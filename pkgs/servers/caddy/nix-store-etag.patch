From ed1df32e87f14988640ef4720d0c2257e19ea17f Mon Sep 17 00:00:00 2001
From: Emily <vcs@emily.moe>
Date: Sat, 21 Mar 2020 21:12:49 +0000
Subject: [PATCH] fileserver: Use store hash as ETag in /nix/store

---
 modules/caddyhttp/fileserver/staticfiles.go | 40 +++++++++++++++++++--
 1 file changed, 38 insertions(+), 2 deletions(-)

diff --git a/modules/caddyhttp/fileserver/staticfiles.go b/modules/caddyhttp/fileserver/staticfiles.go
index d6cf4d65..6753b14f 100644
--- a/modules/caddyhttp/fileserver/staticfiles.go
+++ b/modules/caddyhttp/fileserver/staticfiles.go
@@ -198,9 +198,16 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 	}
 	defer file.Close()
 
+	var modTime time.Time
+
 	// set the ETag - note that a conditional If-None-Match request is handled
 	// by http.ServeContent below, which checks against this ETag value
-	w.Header().Set("ETag", calculateEtag(info))
+	if ok, etag := nixStoreEtag(info, filename); ok {
+		w.Header().Set("ETag", etag)
+	} else {
+		w.Header().Set("ETag", calculateEtag(info))
+		modTime = info.ModTime()
+	}
 
 	if w.Header().Get("Content-Type") == "" {
 		mtyp := mime.TypeByExtension(filepath.Ext(filename))
@@ -236,7 +243,7 @@ func (fsrv *FileServer) ServeHTTP(w http.ResponseWriter, r *http.Request, next c
 	// that errors generated by ServeContent are written immediately
 	// to the response, so we cannot handle them (but errors there
 	// are rare)
-	http.ServeContent(w, r, info.Name(), info.ModTime(), file)
+	http.ServeContent(w, r, info.Name(), modTime, file)
 
 	return nil
 }
@@ -378,6 +385,35 @@ func calculateEtag(d os.FileInfo) string {
 	return `"` + t + s + `"`
 }
 
+func nixStoreEtag(d os.FileInfo, filename string) (bool, string) {
+	if d.ModTime().Unix() != 1 {
+		return false, ""
+	}
+
+	storePath, err := realPath(filename)
+	if err != nil {
+		return false, ""
+	}
+
+	if !strings.HasPrefix(storePath, nixStorePrefix) {
+		return false, ""
+	}
+
+	storeHash := storePath[len(nixStorePrefix):len(nixStorePrefix)+@nixStoreHashLen@]
+	return true, `"` + storeHash + `"`
+}
+
+const nixStorePrefix = "@nixStoreDir@/"
+
+func realPath(path string) (string, error) {
+	path, err := filepath.Abs(path)
+	if err != nil {
+		return "", err
+	}
+
+	return filepath.EvalSymlinks(path)
+}
+
 func redirect(w http.ResponseWriter, r *http.Request, to string) error {
 	for strings.HasPrefix(to, "//") {
 		// prevent path-based open redirects
-- 
2.25.1

